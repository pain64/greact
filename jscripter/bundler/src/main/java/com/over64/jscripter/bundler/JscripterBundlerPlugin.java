/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.over64.jscripter.bundler;


import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.servlet.ServletContextHandler;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.eclipse.jetty.websocket.server.config.JettyWebSocketServletContainerInitializer;
import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.tasks.SourceSetContainer;
import org.gradle.api.tasks.TaskAction;
import org.gradle.workers.WorkAction;
import org.gradle.workers.WorkParameters;
import org.gradle.workers.WorkerExecutor;

import javax.inject.Inject;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.file.*;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import java.util.zip.ZipEntry;


// FIXME: rename to JScripter
public class JscripterBundlerPlugin implements Plugin<Project> {

    record LibrariesCode(String js, String css) { }
    public static class WorkServerParams implements WorkParameters {
        static String message;
    }

    public abstract static class WebServer implements WorkAction<WorkServerParams> {
        @Override public void execute() {
            try {
                System.out.println("AT EXECUTOR");
                _execute();
            } catch (Exception e) {
                System.out.println("RT EXCEPTION: " + e);
                throw new RuntimeException(e);
            }
        }

        void _execute() throws Exception {
            try {
                var client = new WebSocketClient();
                try {
                    client.start();
                    var socket = new ClientHandler();
                    var session = client.connect(socket, URI.create("ws://localhost:8080/greact_livereload_events/")).get();

                    session.getRemote().sendString(getParameters().message);

                    session.close(org.eclipse.jetty.websocket.api.StatusCode.NORMAL, "I'm done");
                    System.out.println("AFTER SEND");
                } finally {
                    client.stop();
                }
            } catch (java.util.concurrent.ExecutionException t) {
                if (t.getCause() instanceof java.net.ConnectException) {
                    System.out.println("start livereload server!");
                    var server = new Server();
                    var connector = new ServerConnector(server);
                    connector.setPort(8080);
                    server.addConnector(connector);

                    var context = new ServletContextHandler(ServletContextHandler.SESSIONS);
                    context.setContextPath("/");
                    server.setHandler(context);

                    JettyWebSocketServletContainerInitializer.configure(context, (servletContext, wsContainer) -> {
                        wsContainer.setMaxTextMessageSize(65535);
                        wsContainer.setIdleTimeout(Duration.ofHours(1));
                        wsContainer.addMapping("/greact_livereload_events/*", ServerHandler.class);
                    });

                    server.start();
                } else throw t;
            } catch (java.io.IOException t) {
                throw new GradleException("Error: cannot use port 8080 for GReact livereload. Is it available?", t);
            }
        }

        public static class ClientHandler implements org.eclipse.jetty.websocket.api.WebSocketListener { }

        public static class ServerHandler implements org.eclipse.jetty.websocket.api.WebSocketListener {
            static ConcurrentHashMap.KeySetView<Session, Boolean> sessions = ConcurrentHashMap.newKeySet();
            volatile Session session = null;

            @Override public void onWebSocketConnect(Session ss) {
                this.session = ss;
                sessions.add(ss);
            }

            @Override public void onWebSocketClose(int statusCode, String reason) {
                var ss = session;
                if (ss != null) sessions.remove(ss);
            }

            @Override public void onWebSocketText(String message) {
                System.out.println("####HAS NEW WEBSOCKET MESSAGE: " + message);
                if (!message.equals("reload") && !message.startsWith("update")) return;
                var me = session;

                sessions.forEach(ss -> {
                    if (ss != me)
                        try {
                            ss.getRemote().sendString(message);
                        } catch (java.lang.Exception ex) {
                            System.out.println("failed to send livereload message to remote: " + ss.getRemoteAddress());
                        }
                });
            }
        }
    }

    public static class DebugBuild extends DefaultTask {
        @TaskAction void debug() {
            System.out.println("DebugBuild");
        }
    }

    public static class HotReload extends DefaultTask {
        LibrariesCode fetchLibrariesCode() {
            var js = new StringBuilder();
            var css = new StringBuilder();

            var runtimeClassPath = getProject().getConfigurations().getByName("runtimeClasspath");
            StreamSupport.stream(runtimeClassPath.spliterator(), false)
                .map(cp -> new HotReload.ClassPathWithModule<>(cp, walkOverJar(cp)))
                .filter(cpWithMod -> cpWithMod.mod.resources.stream().anyMatch(r -> r.name.endsWith(".js")))
                .forEach(cpWithMod -> {
                    var libResourcesOrdered = buildDependencies(cpWithMod.mod);

                    var libJs = libResourcesOrdered.stream().filter(r -> r.name.endsWith(".js"));
                    var libCss = libResourcesOrdered.stream().filter(r -> r.name.endsWith(".css"));

                    js.append(String.join("\n", libJs.map(HotReload.RResource::data).toList()));
                    css.append(String.join("\n", libCss.map(HotReload.RResource::data).toList()));
                });

            return new LibrariesCode(js.toString(), css.toString());
        }

        LinkedHashSet<RResource<Path>> fetchLocalCode(SourceSetContainer sourceSets, Path stylesDir) {
            var localJs = sourceSets.getByName("main")
                .getOutput().getClassesDirs().getFiles().stream()
                .map(this::walkOverDirectory)
                .reduce(new ModuleCode<>(List.of(), Map.of()), (m1, m2) ->
                    new ModuleCode<>(
                        new ArrayList<>(m2.resources) {{ addAll(m2.resources); }},
                        new HashMap<>(m1.dependencies) {{ putAll(m2.dependencies); }}));

            var localCss = walkOverDirectory(stylesDir.toFile()).resources;

            // FIXME: make listConcat & mapConcat method
            var localModule = new ModuleCode<>(
                new ArrayList<>(localJs.resources) {{ addAll(localCss); }},
                localJs.dependencies);

            return buildDependencies(localModule);
        }

        final WorkerExecutor workerExecutor;

        @Inject public HotReload(WorkerExecutor workerExecutor) {
            this.workerExecutor = workerExecutor;
        }

        String readJar(JarFile jar, ZipEntry entry) {
            try {
                return new String(jar.getInputStream(entry).readAllBytes());
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }

        String readFile(File file) {
            try {
                return new String(Files.readAllBytes(file.toPath()));
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }

        String removeSuffix(String s, String suffix) {
            return s.endsWith(suffix)
                ? s.substring(0, s.length() - suffix.length())
                : s;
        }

        record ClassPathWithModule<D>(File classPath, ModuleCode<D> mod) { }
        record RResource<D>(String name, D data) { }
        record ModuleCode<D>(List<RResource<D>> resources,
                             Map<String, List<String>> dependencies) { }

        <E, D> ModuleCode<D> walkOver(Stream<E> stream,
                                      Function<E, String> entryName,
                                      Function<E, String> entryContent,
                                      Function<E, D> entryData) {

            var dependencies = new HashMap<String, List<String>>();
            var resources =
                stream.filter(e -> {
                        var name = entryName.apply(e);
                        if (name.endsWith(".js") || name.endsWith(".css")) return true;
                        else {
                            if (name.endsWith(".js.dep")) {
                                var depData = entryContent.apply(e);
                                var depName = removeSuffix(name, ".dep");
                                if (!depData.isEmpty())
                                    dependencies.put(
                                        depName,
                                        Arrays.stream(depData.split("\n"))
                                            .filter(s -> !s.isEmpty())
                                            .toList());
                            }
                            return false;
                        }
                    })
                    .map(e -> new RResource<>(entryName.apply(e), entryData.apply(e)))
                    .toList();

            return new ModuleCode<>(resources, dependencies);
        }

        ModuleCode<String> walkOverJar(File jarFile) {
            try (var jar = new JarFile(jarFile)) {
                return walkOver(jar.stream(),
                    je -> je.getName().replace("/", "."),
                    je -> readJar(jar, je),
                    je -> readJar(jar, je));
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
        }

        ModuleCode<Path> walkOverDirectory(File baseDir) {
            Function<Path, String> pathToResourceName = path -> {
                var fullName = path.toString();
                if (fullName.endsWith(".js") || fullName.endsWith(".js.dep"))
                    return fullName
                        .replace(baseDir.toPath().toString(), "")
                        .substring(1) // strip /
                        .replace("/", ".");
                else
                    return path.getFileName().toString(); // css
            };

            final Stream<Path> pathsStream;

            try {
                pathsStream = Files.walk(baseDir.toPath()).filter(Files::isRegularFile);
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }

            return walkOver(
                pathsStream,
                pathToResourceName,
                p -> readFile(p.toFile()),
                p -> p);
        }

        <D> void pushDependencies2(ModuleCode<D> module,
                                   LinkedHashSet<RResource<D>> dest,
                                   RResource<D> resource) {

            var deps = module.dependencies.getOrDefault(resource.name, List.of());
            for (var dep : deps) {
                // FIXME: try to find dep in library code
                var depResource = module.resources.stream()
                    .filter(r -> r.name.equals(dep))
                    .findFirst();

//                        ?: throw RuntimeException("""
//                        cannot find resource for dependency: $deps
//                        all resources: ${module.resources.joinToString("\n") { it.name }}
//                        """.trimIndent())
                depResource.ifPresent(dr ->
                    pushDependencies2(module, dest, dr));
            }

            dest.add(resource);
        }

        <D> LinkedHashSet<RResource<D>> buildDependencies(ModuleCode<D> module) {
            var dest = new LinkedHashSet<RResource<D>>();
            for (var resource : module.resources)
                pushDependencies2(module, dest, resource);
            return dest;
        }
        record Delta(boolean isLibrariesChanged, List<String> localFilesChanged) { }
        Delta debugBuild(SourceSetContainer sourceSets) throws IOException {
            var currentTime = System.currentTimeMillis();

            var resourceDir = sourceSets.getByName("main").getOutput().getResourcesDir();

            var stylesDir = resourceDir.toPath().resolve("styles");
            var bundleDir = resourceDir.toPath().resolve("bundle");
            if (!bundleDir.toFile().exists()) Files.createDirectory(bundleDir);

            if (Files.exists(bundleDir.resolve("main.js")))
                Files.delete(bundleDir.resolve("main.js"));
            if (Files.exists(bundleDir.resolve("main.css")))
                Files.delete(bundleDir.resolve("main.css"));

            var latestLibMtime = bundleDir.resolve("latest_lib_mtime");

            if (!Files.exists(latestLibMtime)) {
                Files.createFile(latestLibMtime);
                if (!latestLibMtime.toFile().setLastModified(0))
                    throw new IOException("Can't set lastModified");
            }

            var runtimeClassPath = getProject().getConfigurations().getByName("runtimeClasspath");
            long maxJarMtime = StreamSupport.stream(runtimeClassPath.spliterator(), false).map(File::lastModified).max(Long::compare).get();

            var classPathIsChanged = maxJarMtime > latestLibMtime.toFile().lastModified();

            if (classPathIsChanged) {
                if (!latestLibMtime.toFile().setLastModified(maxJarMtime))
                    throw new IOException("Can't set lastModified");

                var libs = fetchLibrariesCode();

                var moduleJsPath = Paths.get(bundleDir + "/lib.js");
                var moduleCssPath = Paths.get(bundleDir + "/lib.css");

                Files.writeString(moduleJsPath, libs.js);
                Files.writeString(moduleCssPath, libs.css);
            }

            var localResourceOrdered = fetchLocalCode(sourceSets, stylesDir);

            System.out.println("lib js resolution took: " + (System.currentTimeMillis() - currentTime) + "ms");


            var bundlePath = bundleDir.resolve(".bundle");
            var bundleFile = bundlePath.toFile();
            var bundleExists = bundleFile.exists();
            var lastBuild = bundleFile.lastModified();

            var changedFiles_ = new ArrayList<String>();

            for (var res : localResourceOrdered) {
                if (!bundleExists || res.data.toFile().lastModified() > lastBuild) {
                    changedFiles_.add(res.name);
                    var dest = bundleDir.resolve(res.name);

                    // При первой сборке просто копируем файлы без
                    // префикса `window. = class`
                    // При последующих livereload сборках добавляем префикс
                    // TODO: подумать над тем, чтобы JScripter сам добавлял префикс
                    if (bundleExists && res.name.endsWith(".js")) {
                        var adopted = replaceClassDeclarationWithWindow(Files.readString(res.data));
                        var destFile = dest.toFile();
                        if (!destFile.exists()) { var __ = destFile.createNewFile(); }
                        Files.writeString(dest, adopted, StandardOpenOption.TRUNCATE_EXISTING);
                    } else
                        Files.copy(res.data, dest, StandardCopyOption.REPLACE_EXISTING);
                }
            }
            Files.writeString(bundlePath, "lib.js\nlib.css\n");
            Files.writeString(bundlePath, Stream.of(localResourceOrdered)
                .flatMap(Collection::stream)
                .map(r -> r.name)
                .collect(Collectors.joining("\n")), StandardOpenOption.APPEND);

            return new Delta(classPathIsChanged, changedFiles_);
        }

        @TaskAction void hotReload() throws Exception {
            var currentTime = System.currentTimeMillis();

            var sourceSets = (org.gradle.api.tasks.SourceSetContainer)
                ((org.gradle.api.plugins.ExtensionAware) getProject()).getExtensions().getByName("sourceSets");

            var resourceDir = sourceSets.getByName("main").getOutput().getResourcesDir();
            var bundleDir = resourceDir.toPath().resolve("bundle");
            var bundlePath = bundleDir.resolve(".bundle");

            var delta = debugBuild((org.gradle.api.tasks.SourceSetContainer)
                ((org.gradle.api.plugins.ExtensionAware) getProject()).getExtensions().getByName("sourceSets"));

            Files.writeString(bundlePath, "\nlivereload", StandardOpenOption.APPEND);

            var message = "";

            if (delta.isLibrariesChanged || delta.localFilesChanged.stream().anyMatch(n -> !(n.endsWith(".js") || n.endsWith(".css"))))
                message = "reload";
            else {
                var messageUpdate = new StringBuilder("update");
                for (var file : delta.localFilesChanged)
                    messageUpdate.append("\n").append(file);

                if (!messageUpdate.toString().equals("update"))
                    message = messageUpdate.toString();
            }

            System.out.println("BEFORE WS MESSAGE SEND! TOOK " + (System.currentTimeMillis() - currentTime) + "ms");

            var finalMessage = message;

            workerExecutor.noIsolation().submit(WebServer.class, workServerParams -> WorkServerParams.message = finalMessage);
        }

        private CharSequence replaceClassDeclarationWithWindow(String readString) {
            return readString.replaceAll("class (\\S*) \\{", "window.$1 = class {");
        }
    }

    public static class ProductBuild extends DefaultTask {
        final WorkerExecutor workerExecutor;

        @Inject
        public ProductBuild(WorkerExecutor workerExecutor) {
            this.workerExecutor = workerExecutor;
        }

        interface Appender {
            void appendAndDrop(FileOutputStream to, String fileName) throws IOException;
        }

        @TaskAction
        void productionBuild() throws IOException, NoSuchAlgorithmException {
            var sourceSets = (org.gradle.api.tasks.SourceSetContainer)
                ((org.gradle.api.plugins.ExtensionAware) getProject()).getExtensions().getByName("sourceSets");

            var resourceDir = sourceSets.getByName("main").getOutput().getResourcesDir();
            var bundleDir = resourceDir.toPath().resolve("bundle");
            var bundleFile = bundleDir.resolve(".bundle");
            var allFileNames = Files.readAllLines(bundleFile);

            var mainJsFile = bundleDir.resolve("main.js").toFile();
            var mainCssFile = bundleDir.resolve("main.css").toFile();
            if (!mainJsFile.exists()) { var __ = mainJsFile.createNewFile(); }
            if (!mainCssFile.exists()) { var __ = mainCssFile.createNewFile(); }

            Appender appender = (to, fileName) -> {
                var inFile = bundleDir.resolve(fileName).toFile();
                try (var in = new FileInputStream(inFile)) {
                    var inCh = in.getChannel();
                    inCh.transferTo(0, inCh.size(), to.getChannel());
                }
                var __ = inFile.delete();
            };

            try (var outJs = new FileOutputStream(mainJsFile, false);
                 var outCss = new FileOutputStream(mainCssFile, false)) {
                for (var fileName : allFileNames)
                    if (fileName.endsWith(".js")) appender.appendAndDrop(outJs, fileName);
                    else if (fileName.endsWith(".css")) appender.appendAndDrop(outCss, fileName);
            }

            var __ = bundleFile.toFile().delete();
            __ = bundleFile.toFile().createNewFile();

            var sha1 = MessageDigest.getInstance("SHA-1");
            var hashJs = byteArrayToHexString(sha1.digest(Files.readAllBytes(bundleDir.resolve("main.js"))));
            var hashCss = byteArrayToHexString(sha1.digest(Files.readAllBytes(bundleDir.resolve("main.css"))));

            Files.writeString(bundleFile, "main.css " + hashCss + "\nmain.js " + hashJs);
        }
    }
    // TODO:
    // 1 - функция для получения содержимого библиотечных js и css                       +
    //     record LibrariesCode(String js, String css) {}                                +
    //     LibrariesCode fetchLibrariesCode() {} (строка 323 - 341)                      +
    // 2 - функция для получения содержимого локального кода js и css (строка 307 - 320) +
    //     LinkedHashSet<RResource<Path>> fetchLocalCode()                               +
    // 2 - функция Delta debugBuild() (task bundler-debug-build)
    //       - stateful - содержимое каталога bundle
    //       - хранит bundle/latest_lib_mtime
    //          - файл, mtime которого равен максимальному mtime jar файлов
    //          - если есть jar файл, mtime которого больше чем
    //             latest_lib_mtime, то вызывает fetchLibrariesCode() и дампит новые
    //             версии lib.css и lib.js
    //       - вызывает fetchLocalCode(), копирует в bundledir, пишет в bundlefile
    //       - работает с bundleFile (строка 354 - 371)
    //          - патчит window.classXXX =
    //          - хранит mtime файлов бандла
    //       - возвращает список имен измененных файлов и флаг был ли изменен classPath
    //       record Delta(boolean isLibrariesChanged, List<String> localFilesChanged)
    // 3 - функция hotReload()
    //     - вызывает debugBuild и отправляет сообщение по WS
    //        - если isLibrariesChanged то сообщение "reload"
    //        - иначе отправляем сообщение:
    //             update
    //             file1
    //             file2
    //             ...
    //        - сообщение отправляется не через static поле а как поле класса
    //            а через поле workerServerParams (строка 381)
    // 4 - функция productionBuild()
    //    - stateful - сносит содержимое bundle dir
    //    - вызывает fetchLibrariesCode()
    //       - записывает lib.css и lib.js в bundleFile заносит эти файлы с хэшами
    //    - вызывает fetchLocalCode, склеивает в main.css и main.js, вычисляет хэши и заносит в bundleFile
    // РЕФАКТОР ФАЙЛОВ
    // 1 - WebsocketSender
    // 2 - CodeAnalyze - fetchLibrariesCode, fetchLocalCode, ModuleCode, RResource и т.д.
    // 3 - JScripterBundlerPlugin - таски, работа с bundle
    // РЕФАКТОР ТАСКОВ:
    //  Мотивация: не поднимать websocket просто так если юзер просто скомпилировал проект
    //    то есть, явно не использовал hot-reload
    //  1 task: bundler-debug-build
    //      от него зависит classes
    //  2 task: bundler-production-build
    //      от него зависит jar
    //  3 task: hot-reload
    //      он зависит от compileJava, processResources

    // NOTA BENE:
    //  - используем NIO (zero-copy) для работы с файлами (426-431, 366, 369)

    public void apply(Project project) {
        project.getPlugins().apply("java");
        var classes = project.getTasks().getByName("classes");

        project.getTasks().register("bundler-debug-build", DebugBuild.class);
        classes.dependsOn("bundler-debug-build");

        // classes.dependsOn("bundler-debug-build");
        classes.dependsOn("hot-reload"); // Delete

        project.getTasks().register("hot-reload", HotReload.class, reload ->
            reload.dependsOn("compileJava", "processResources"));

        project.getTasks().register("bundler-production-build", ProductBuild.class);

        project.getTasks().getByName("jar").dependsOn("bundler-production-build");
    }

    private static String byteArrayToHexString(byte[] b) {
        var result = new StringBuilder();
        for (byte value : b)
            result.append(Integer.toString((value & 0xff) + 0x100, 16).substring(1));

        return result.toString();
    }
}
